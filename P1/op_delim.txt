/*
    a mellor opcion é
    switch(c1){
        case '*':
            return c2 == '*'? POW : -1;
    }
    nunha funcion
    e despois 
    res = funcion();
    if(res == -1){
        compLexicoNum = res;
    }else if(res == -2){
        error por culpa do != (solo !)
    }else{
        retrocede1();
        compLexicoNum = (int)c1;
    }
*/


//uno
(
)
[
]
{
}
,
;
~


//dos
@=
==
++
+=
--
-=
->
:=
//
/=
**
*=
%=
>=
>>
<=
<<
|=
^=
&=
!= (este a ! sola daria error)


matriz 14x7

==================================
primeiros elementos

// columna primeiro char, fila segundo elemento
// 0 non é valido (solo vale o primeiro char)
// 1 é valido (char1char2 é un operador ou delimitador valido)
const char opAndDelims[7][14] = {
    //      !   %   &   *   +   -   /   :   <   =   >   @   ^   |
    /* * */{0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
    /* + */{0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0},
    /* - */{0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0},
    /* / */{0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0},
    /* < */{0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0},
    /* = */{1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1},
    /* > */{0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0},
};


@=
==
++
+=
--
-=
->
:=
//
/=
**
*=
>=
>>
<=
<<
|=
^=
&=
switch (c){
    case: '!': return c2 == '='? NOT_EQUALS : -2;
    case: '%': return c2 == '='? MOD_EQUALS : -1;
    case: '&': return 2;
    case: '*': return 3;
    case: '+': return 4;
    case: '-': return 5;
    case: '/': return 6;
    case: ':': return 7;
    case: '<': return 8;
    case: '=': return 9;
    case: '>': return 10;
    case: '@': return 11;
    case: '^': return 12;
    case: '|': return 13;
}



segundos elementos
switch(cc){
    case: '*': return 0;
    case: '+': return 1;
    case: '-': return 2;
    case: '/': return 3;
    case: '<': return 4;
    case: '=': return 5;
    case: '>': return 6;
}